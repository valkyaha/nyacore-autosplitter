//! ASL Runtime - Executes parsed ASL scripts

use std::collections::HashMap;
use crate::asl::ast::*;
use crate::asl::types::{Value, VarDefinition, VariableStore};

/// Result of evaluating an action block
#[derive(Debug, Clone)]
pub struct ActionResult {
    /// Return value (if any)
    pub value: Option<Value>,
    /// Whether the action returned early
    pub returned: bool,
}

impl Default for ActionResult {
    fn default() -> Self {
        Self {
            value: None,
            returned: false,
        }
    }
}

/// Events generated by the autosplitter
#[derive(Debug, Clone, Default)]
pub struct AutosplitEvents {
    /// Timer should start
    pub start: bool,
    /// Timer should split
    pub split: bool,
    /// Timer should reset
    pub reset: bool,
    /// Game is loading (pause game time)
    pub is_loading: bool,
    /// Game time in milliseconds (if provided)
    pub game_time: Option<u64>,
}

/// ASL Runtime - executes parsed ASL scripts
pub struct AslRuntime {
    /// The parsed script
    script: AslScript,
    /// Variable store with current/old tracking
    variables: VariableStore,
    /// Local variables (for action blocks)
    locals: HashMap<String, Value>,
    /// User settings
    settings: HashMap<String, Value>,
    /// Whether the script has been initialized
    initialized: bool,
    /// Process names this script supports
    process_names: Vec<String>,
}

impl AslRuntime {
    /// Create a new runtime from a parsed script
    pub fn new(script: AslScript) -> Self {
        // Collect process names and variable definitions from state blocks
        let mut process_names = Vec::new();
        let mut definitions = Vec::new();

        for state in &script.states {
            process_names.extend(state.process_names.clone());
            definitions.extend(state.variables.clone());
        }

        let mut variables = VariableStore::new();
        for def in definitions {
            variables.add_definition(def);
        }

        Self {
            script,
            variables,
            locals: HashMap::new(),
            settings: HashMap::new(),
            initialized: false,
            process_names,
        }
    }

    /// Get process names this script supports
    pub fn process_names(&self) -> &[String] {
        &self.process_names
    }

    /// Get variable definitions
    pub fn variable_definitions(&self) -> &[VarDefinition] {
        &self.variables.definitions
    }

    /// Set a setting value
    pub fn set_setting(&mut self, name: &str, value: Value) {
        self.settings.insert(name.to_string(), value);
    }

    /// Get a setting value
    pub fn get_setting(&self, name: &str) -> Value {
        self.settings.get(name).cloned().unwrap_or(Value::Null)
    }

    /// Update a variable's current value (called after memory read)
    pub fn set_variable(&mut self, name: &str, value: Value) {
        self.variables.set(name, value);
    }

    /// Prepare for a new tick (moves current to old)
    pub fn tick(&mut self) {
        self.variables.tick();
    }

    /// Update all variables from memory context
    /// Call this after tick() and before run_tick()
    #[cfg(target_os = "windows")]
    pub fn update_from_memory(&mut self, ctx: &crate::asl::memory::AslMemoryContext) {
        for def in &self.variables.definitions.clone() {
            let value = ctx.read_variable(def);
            self.variables.set(&def.name, value);
        }
    }

    /// Update all variables from memory context (Linux)
    #[cfg(target_os = "linux")]
    pub fn update_from_memory(&mut self, ctx: &crate::asl::memory::AslMemoryContext) {
        for def in &self.variables.definitions.clone() {
            let value = ctx.read_variable(def);
            self.variables.set(&def.name, value);
        }
    }

    /// Run startup action (when process attaches)
    pub fn on_startup(&mut self) -> ActionResult {
        if let Some(action) = self.script.startup.clone() {
            self.execute_action(&action)
        } else {
            ActionResult::default()
        }
    }

    /// Run shutdown action (when process detaches)
    pub fn on_shutdown(&mut self) -> ActionResult {
        self.initialized = false;
        if let Some(action) = self.script.shutdown.clone() {
            self.execute_action(&action)
        } else {
            ActionResult::default()
        }
    }

    /// Run init action (once per game start)
    pub fn on_init(&mut self) -> ActionResult {
        self.initialized = true;
        if let Some(action) = self.script.init.clone() {
            self.execute_action(&action)
        } else {
            ActionResult::default()
        }
    }

    /// Run exit action (once per game exit)
    pub fn on_exit(&mut self) -> ActionResult {
        if let Some(action) = self.script.exit.clone() {
            self.execute_action(&action)
        } else {
            ActionResult::default()
        }
    }

    /// Run update action (every tick, before other actions)
    pub fn on_update(&mut self) -> ActionResult {
        if let Some(action) = self.script.update.clone() {
            self.execute_action(&action)
        } else {
            ActionResult::default()
        }
    }

    /// Run all tick actions and return events
    pub fn run_tick(&mut self) -> AutosplitEvents {
        let mut events = AutosplitEvents::default();

        // Run update first
        self.on_update();

        // Check start
        if let Some(action) = self.script.start.clone() {
            let result = self.execute_action(&action);
            if let Some(Value::Bool(true)) = result.value {
                events.start = true;
            }
        }

        // Check split
        if let Some(action) = self.script.split.clone() {
            let result = self.execute_action(&action);
            if let Some(Value::Bool(true)) = result.value {
                events.split = true;
            }
        }

        // Check reset
        if let Some(action) = self.script.reset.clone() {
            let result = self.execute_action(&action);
            if let Some(Value::Bool(true)) = result.value {
                events.reset = true;
            }
        }

        // Check isLoading
        if let Some(action) = self.script.is_loading.clone() {
            let result = self.execute_action(&action);
            if let Some(Value::Bool(true)) = result.value {
                events.is_loading = true;
            }
        }

        // Check gameTime
        if let Some(action) = self.script.game_time.clone() {
            let result = self.execute_action(&action);
            if let Some(value) = result.value {
                // Convert to milliseconds
                match value {
                    Value::Int(ms) => events.game_time = Some(ms as u64),
                    Value::UInt(ms) => events.game_time = Some(ms),
                    Value::Float(secs) => events.game_time = Some((secs * 1000.0) as u64),
                    _ => {}
                }
            }
        }

        events
    }

    /// Execute an action block
    fn execute_action(&mut self, action: &ActionBlock) -> ActionResult {
        self.locals.clear();

        for stmt in &action.statements {
            let result = self.execute_statement(stmt);
            if result.returned {
                return result;
            }
        }

        ActionResult::default()
    }

    /// Execute a statement
    fn execute_statement(&mut self, stmt: &Statement) -> ActionResult {
        match stmt {
            Statement::VarDecl { name, value } => {
                let val = self.evaluate_expression(value);
                self.locals.insert(name.clone(), val);
                ActionResult::default()
            }

            Statement::Assignment { target, value } => {
                let val = self.evaluate_expression(value);
                self.locals.insert(target.clone(), val);
                ActionResult::default()
            }

            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.evaluate_expression(condition);
                if cond.as_bool() {
                    for stmt in then_branch {
                        let result = self.execute_statement(stmt);
                        if result.returned {
                            return result;
                        }
                    }
                } else if let Some(else_stmts) = else_branch {
                    for stmt in else_stmts {
                        let result = self.execute_statement(stmt);
                        if result.returned {
                            return result;
                        }
                    }
                }
                ActionResult::default()
            }

            Statement::Return { value } => {
                let val = value.as_ref().map(|e| self.evaluate_expression(e));
                ActionResult {
                    value: val,
                    returned: true,
                }
            }

            Statement::Expression(expr) => {
                self.evaluate_expression(expr);
                ActionResult::default()
            }
        }
    }

    /// Evaluate an expression
    fn evaluate_expression(&self, expr: &Expression) -> Value {
        match expr {
            Expression::Literal(lit) => self.literal_to_value(lit),

            Expression::Variable { scope, name } => {
                match scope {
                    VarScope::Current => self.variables.get_current(name),
                    VarScope::Old => self.variables.get_old(name),
                    VarScope::Local => self.locals.get(name).cloned().unwrap_or(Value::Null),
                    VarScope::Settings => self.settings.get(name).cloned().unwrap_or(Value::Null),
                }
            }

            Expression::Binary { left, op, right } => {
                let l = self.evaluate_expression(left);
                let r = self.evaluate_expression(right);
                self.evaluate_binary_op(&l, *op, &r)
            }

            Expression::Unary { op, expr } => {
                let val = self.evaluate_expression(expr);
                self.evaluate_unary_op(*op, &val)
            }

            Expression::Call { name, args } => {
                let arg_vals: Vec<Value> = args.iter()
                    .map(|a| self.evaluate_expression(a))
                    .collect();
                self.call_function(name, &arg_vals)
            }

            Expression::Member { object, member } => {
                let obj = self.evaluate_expression(object);
                self.access_member(&obj, member)
            }

            Expression::Index { object, index } => {
                let obj = self.evaluate_expression(object);
                let idx = self.evaluate_expression(index);
                self.access_index(&obj, &idx)
            }

            Expression::Ternary { condition, then_expr, else_expr } => {
                let cond = self.evaluate_expression(condition);
                if cond.as_bool() {
                    self.evaluate_expression(then_expr)
                } else {
                    self.evaluate_expression(else_expr)
                }
            }
        }
    }

    /// Convert literal to value
    fn literal_to_value(&self, lit: &Literal) -> Value {
        match lit {
            Literal::Null => Value::Null,
            Literal::Bool(b) => Value::Bool(*b),
            Literal::Int(i) => Value::Int(*i),
            Literal::Float(f) => Value::Float(*f),
            Literal::String(s) => Value::String(s.clone()),
        }
    }

    /// Evaluate binary operation
    fn evaluate_binary_op(&self, left: &Value, op: BinaryOp, right: &Value) -> Value {
        match op {
            // Arithmetic
            BinaryOp::Add => {
                match (left, right) {
                    (Value::String(a), Value::String(b)) => Value::String(format!("{}{}", a, b)),
                    (Value::String(a), b) => Value::String(format!("{}{}", a, b.as_string())),
                    (a, Value::String(b)) => Value::String(format!("{}{}", a.as_string(), b)),
                    (Value::Float(_), _) | (_, Value::Float(_)) => {
                        Value::Float(left.as_float() + right.as_float())
                    }
                    _ => Value::Int(left.as_int() + right.as_int()),
                }
            }
            BinaryOp::Sub => {
                if matches!(left, Value::Float(_)) || matches!(right, Value::Float(_)) {
                    Value::Float(left.as_float() - right.as_float())
                } else {
                    Value::Int(left.as_int() - right.as_int())
                }
            }
            BinaryOp::Mul => {
                if matches!(left, Value::Float(_)) || matches!(right, Value::Float(_)) {
                    Value::Float(left.as_float() * right.as_float())
                } else {
                    Value::Int(left.as_int() * right.as_int())
                }
            }
            BinaryOp::Div => {
                if matches!(left, Value::Float(_)) || matches!(right, Value::Float(_)) {
                    Value::Float(left.as_float() / right.as_float())
                } else {
                    let r = right.as_int();
                    if r == 0 {
                        Value::Int(0)
                    } else {
                        Value::Int(left.as_int() / r)
                    }
                }
            }
            BinaryOp::Mod => {
                let r = right.as_int();
                if r == 0 {
                    Value::Int(0)
                } else {
                    Value::Int(left.as_int() % r)
                }
            }

            // Comparison
            BinaryOp::Eq => Value::Bool(left.equals(right)),
            BinaryOp::Ne => Value::Bool(!left.equals(right)),
            BinaryOp::Lt => Value::Bool(left.compare(right) < 0),
            BinaryOp::Le => Value::Bool(left.compare(right) <= 0),
            BinaryOp::Gt => Value::Bool(left.compare(right) > 0),
            BinaryOp::Ge => Value::Bool(left.compare(right) >= 0),

            // Logical
            BinaryOp::And => Value::Bool(left.as_bool() && right.as_bool()),
            BinaryOp::Or => Value::Bool(left.as_bool() || right.as_bool()),

            // Bitwise
            BinaryOp::BitAnd => Value::Int(left.as_int() & right.as_int()),
            BinaryOp::BitOr => Value::Int(left.as_int() | right.as_int()),
            BinaryOp::BitXor => Value::Int(left.as_int() ^ right.as_int()),
            BinaryOp::Shl => Value::Int(left.as_int() << (right.as_int() as u32)),
            BinaryOp::Shr => Value::Int(left.as_int() >> (right.as_int() as u32)),
        }
    }

    /// Evaluate unary operation
    fn evaluate_unary_op(&self, op: UnaryOp, val: &Value) -> Value {
        match op {
            UnaryOp::Not => Value::Bool(!val.as_bool()),
            UnaryOp::Neg => {
                match val {
                    Value::Float(f) => Value::Float(-f),
                    _ => Value::Int(-val.as_int()),
                }
            }
            UnaryOp::BitNot => Value::Int(!val.as_int()),
        }
    }

    /// Call a built-in function
    fn call_function(&self, name: &str, _args: &[Value]) -> Value {
        // Built-in functions can be added here
        match name {
            // Add built-in functions as needed
            _ => Value::Null,
        }
    }

    /// Access a member of a value
    fn access_member(&self, _obj: &Value, _member: &str) -> Value {
        // Member access for complex types
        Value::Null
    }

    /// Access an index of a value
    fn access_index(&self, obj: &Value, index: &Value) -> Value {
        match obj {
            Value::ByteArray(bytes) => {
                let idx = index.as_int() as usize;
                if idx < bytes.len() {
                    Value::Int(bytes[idx] as i64)
                } else {
                    Value::Null
                }
            }
            Value::String(s) => {
                let idx = index.as_int() as usize;
                if idx < s.len() {
                    Value::String(s.chars().nth(idx).map(|c| c.to_string()).unwrap_or_default())
                } else {
                    Value::Null
                }
            }
            _ => Value::Null,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::asl::parse_asl;

    #[test]
    fn test_simple_start() {
        let script = r#"
            start {
                return true;
            }
        "#;

        let mut runtime = parse_asl(script).unwrap();
        let events = runtime.run_tick();
        assert!(events.start);
    }

    #[test]
    fn test_variable_comparison() {
        let script = r#"
            state("game.exe") {
                int health : 0x1234;
            }

            start {
                return current.health > 0 && old.health == 0;
            }
        "#;

        let mut runtime = parse_asl(script).unwrap();

        // Set up variables: old.health = 0, current.health = 100
        runtime.set_variable("health", Value::Int(0));
        runtime.tick();
        runtime.set_variable("health", Value::Int(100));

        let events = runtime.run_tick();
        assert!(events.start);
    }

    #[test]
    fn test_split_condition() {
        let script = r#"
            state("game.exe") {
                int level : 0x5678;
            }

            split {
                return current.level > old.level;
            }
        "#;

        let mut runtime = parse_asl(script).unwrap();

        // Level changed from 1 to 2
        runtime.set_variable("level", Value::Int(1));
        runtime.tick();
        runtime.set_variable("level", Value::Int(2));

        let events = runtime.run_tick();
        assert!(events.split);
    }

    #[test]
    fn test_if_statement() {
        let script = r#"
            state("game.exe") {
                int state : 0x100;
            }

            split {
                if (current.state == 5) {
                    return true;
                }
                return false;
            }
        "#;

        let mut runtime = parse_asl(script).unwrap();
        runtime.set_variable("state", Value::Int(5));

        let events = runtime.run_tick();
        assert!(events.split);
    }

    #[test]
    fn test_local_variables() {
        let script = r#"
            start {
                var x = 10;
                var y = 20;
                return x + y == 30;
            }
        "#;

        let mut runtime = parse_asl(script).unwrap();
        let events = runtime.run_tick();
        assert!(events.start);
    }
}
